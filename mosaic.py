"""
Created by kinou.chin 2023/7/27
"""

import json
import os

import cv2
import easyocr

def write_box(image, rect, color=(0, 255, 0)):
    if len(rect) > 0:
        for box in rect:
            cv2.rectangle(image, box[0], box[1], color, 2)


"""
Supported by easyOCR and opencv Cascade classifier
@ref https://github.com/opencv/opencv/tree/master/data/haarcascades
@ref: https://github.com/JaidedAI/EasyOCR
"""


class ImageMosaic:
    def __init__(self,
                 text_recognize=False,
                 _config_file_path='mosaic_config.json',
                 _xml_path='classifier_xml'):
        print('[ImageMosaic] Initializing......')
        # Read Configuration
        with open(_config_file_path) as f:
            conf = json.load(f)

        print('[ImageMosaic] Configuration is found...')
        print(conf)

        self.classifier = []
        self.classifier_config = []
        for m in conf:
            self.classifier += [cv2.CascadeClassifier("/".join([_xml_path, m['xmlName']]))]
            del m['xmlName']
            self.classifier_config += [m]

        # initialize text detector (easyOCR)
        # 36, 41,
        self.text_reader = easyocr.Reader(['en', 'ja'], gpu=True) if text_recognize \
            else easyocr.Reader([], gpu=True, recognizer=False)

        self.text_recognize = text_recognize
        print('[ImageMosaic] Initialization is successfully completed!')

    def mosaic(self, image_folder):
        print('[ImageMosaic] Start mosaic...')
        images, images_gray, filenames = self.load_images_and_preprocess(image_folder)

        for (image, gray, filename) in zip(images, images_gray, filenames):
            # find the area generated by cv2 classifier
            rect = self.detect_general_box(gray)

            # find the text area generated by easyORC
            text_rect = self.detect_text_box_with_recognize(image) if self.text_recognize \
                else self.detect_text_box(image)

            write_box(image, rect)
            write_box(image, text_rect, color=(255, 0, 0))

            # Write to directory
            output_directory = "processed"
            if not os.path.exists(output_directory):
                os.makedirs(output_directory)
            cv2.imwrite("/".join([output_directory, filename]), image)
            print(f"<{filename}> is successfully processed!")

    def detect_general_box(self, image_gray):
        # perform each classifier to write rect
        rect = []
        for (classifier, config) in zip(self.classifier, self.classifier_config):
            _rect = classifier.detectMultiScale(image_gray, **config)
            # () is given when nothing detected
            for box in _rect:
                x, y, w, h = box
                rect += [((x, y), (x + w, y + h))]
        return rect

    def detect_text_box_with_recognize(self, image):
        detected = self.text_reader.readtext(image)
        result = []
        for (box, text, acc) in detected:
            result += [((box[0][0], box[0][1]), (box[2][0], box[2][1]))]
        return result

    def detect_text_box(self, image):
        horizontal_list, _ = self.text_reader.detect(image)
        result = []
        for (x_min, x_max, y_min, y_max) in horizontal_list[0]:
            result += [((x_min, y_min), (x_max, y_max))]

        return result

    def load_images_and_preprocess(self, folder):
        images_gray = []
        images = []
        image_name = []
        for filename in os.listdir(folder):
            img = cv2.imread(os.path.join(folder, filename))
            if img is not None:
                # convert to gray for postprocessing
                gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)
                images.append(img)
                images_gray.append(gray)
                image_name.append(filename)

        return images, images_gray, image_name
